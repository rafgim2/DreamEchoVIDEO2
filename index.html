<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>DreamEcho - Artista</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
  <style>
    html,body{height:100%;margin:0;font-family:sans-serif;background:#f5f5f5;}
    body{display:flex;justify-content:center;align-items:center;text-align:center;}
    .container{max-width:700px;width:95%;padding:2em;background:#fff;border-radius:1em;border:3px solid orange;box-shadow:0 0 20px rgba(0,0,0,.1);}
    h1{font-size:3em;margin-bottom:.2em;}
    .video-container{display:flex;gap:1em;justify-content:center;flex-wrap:wrap;margin-bottom:1em;}
    .video-block {flex:1 1 45%;display:flex;flex-direction:column;align-items:center;}
    .video-block video{width:100%;max-height:250px;background:#000;border-radius:.5em;}
    .video-label{margin-top:0.3em;font-weight:bold;color:#333;}
    #talkBtn{padding:.8em 2em;font-size:1.1em;margin:.5em 0;border:none;border-radius:.7em;background:#ff9800;color:#fff;cursor:pointer;}
    #talkBtn:active{transform:scale(.96);}
    #chatLog{height:150px;overflow-y:auto;border:1px solid #ccc;padding:.5em;margin-bottom:.5em;text-align:left;background:#fafafa;border-radius:.5em;}
    #chatInput{width:70%;padding:.5em;font-size:1em;}
    #sendChatBtn{padding:.6em 1em;font-size:1em;cursor:pointer;margin-left:.5em;}
    .msg-artista{color:blue;}
    #midiSelectContainer select {margin-top:1em; padding:0.5em; font-size:1em;}
    #modoBtns button{margin:0.3em 0.7em;}
  </style>
</head>
<body>
  <div class="container">
    <h1>DreamEcho - Artista</h1>
    <p class="byline"><a href="https://www.youtube.com/@rafgim" target="_blank" rel="noopener">¬© By Rafael Gimeno</a></p>

    <div class="video-container">
      <div class="video-block">
        <video id="localVideo" autoplay muted playsinline></video>
        <p class="video-label">T√∫</p>
      </div>
      <div class="video-block">
        <video id="remoteVideo" autoplay playsinline></video>
        <p class="video-label">Oyente</p>
      </div>
    </div>

    <button id="talkBtn">üì¢ Mant√©n pulsado para hablar</button>

    <div id="modoBtns">
      <button onclick="modoMIDI()">üéπ Usar mi piano digital</button>
      <button onclick="modoVirtual()">üéß Escuchar con sonido virtual</button>
    </div>
    <div id="midiSelectContainer"></div>

    <p id="estado">Conectando...</p>
    <p id="oyentes">Oyentes conectados: --</p>

    <div id="chatControles">
      <div id="chatLog"></div>
      <input id="chatInput" placeholder="Escribe tu mensaje‚Ä¶" />
      <button id="sendChatBtn">üó®Ô∏è Enviar</button>
    </div>
  </div>

  <script>
    const estadoEl = document.getElementById('estado');
    const oyentesEl = document.getElementById('oyentes');
    const chatLog   = document.getElementById('chatLog');
    const chatInput = document.getElementById('chatInput');
    const sendChatBtn = document.getElementById('sendChatBtn');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const talkBtn = document.getElementById('talkBtn');
    const midiSelectContainer = document.getElementById('midiSelectContainer');

    const ws = new WebSocket('wss://dreamecho.onrender.com');
    const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});

    const username = prompt('¬øC√≥mo quieres que te vean en el chat?','Artista')||'Artista';

    // --- WALKIE-TALKIE ---
    let localStream = null;
    let realAudioTrack = null;
    let silentAudioTrack = null;
    let audioSender = null;
    let pressingTalk = false;
    let remoteSpeaking = false;

    // --- MIDI bidireccional ---
    let midiChannelOut = null;    // DataChannel "midi-artista": env√≠a desde el artista
    let midiChannelIn  = null;    // DataChannel "midi-oyente": recibe desde el oyente
    let midiAccess = null;
    let midiOutput = null;
    let sampler = null;
    let pedal = false;
    const notasActivas = new Set();
    const notasSostenidas = new Set();
    let modo = "ninguno"; // "midi" o "virtual"

    // --- MIDI OUTPUT/INPUT LOGIC ---
    function modoMIDI() {
      modo = "midi";
      midiSelectContainer.innerHTML = "Buscando dispositivos MIDI‚Ä¶";
      navigator.requestMIDIAccess().then(ma => {
        midiAccess = ma;
        const outputs = Array.from(ma.outputs.values());
        if (!outputs.length) {
          midiSelectContainer.innerHTML = 'No hay dispositivos MIDI.';
          midiOutput = null;
          return;
        }
        midiSelectContainer.innerHTML = '';
        const sel = document.createElement('select');
        sel.innerHTML = '<option value="">-- Elige salida MIDI --</option>';
        outputs.forEach(o => sel.innerHTML += `<option value="${o.id}">${o.name}</option>`);
        sel.onchange = () => {
          midiOutput = ma.outputs.get(sel.value);
          estadoEl.textContent = `Salida MIDI: ${midiOutput ? midiOutput.name : "ninguna"}`;
        };
        sel.value = outputs[0].id;
        sel.dispatchEvent(new Event('change'));
        midiSelectContainer.appendChild(sel);
      }).catch(() => {
        midiSelectContainer.innerHTML = 'No se pudo acceder a MIDI.';
      });
    }
    async function modoVirtual() {
      modo = "virtual";
      midiOutput = null;
      midiSelectContainer.innerHTML = '';
      pedal = false; notasActivas.clear(); notasSostenidas.clear();
      await Tone.start();
      sampler = new Tone.Sampler({
        urls: {
          A0: 'A0.mp3', C1: 'C1.mp3', 'D#1': 'Ds1.mp3', 'F#1': 'Fs1.mp3',
          A1: 'A1.mp3', C2: 'C2.mp3', 'D#2': 'Ds2.mp3', 'F#2': 'Fs2.mp3',
          A2: 'A2.mp3', C3: 'C3.mp3', 'D#3': 'Ds3.mp3', 'F#3': 'Fs3.mp3',
          A3: 'A3.mp3', C4: 'C4.mp3', 'D#4': 'Ds4.mp3', 'F#4': 'Fs4.mp3',
          A4: 'A4.mp3', C5: 'C5.mp3', 'D#5': 'Ds5.mp3', 'F#5': 'Fs5.mp3',
          A5: 'A5.mp3', C6: 'C6.mp3', 'D#6': 'Ds6.mp3', 'F#6': 'Fs6.mp3',
          A7: 'A7.mp3', C8: 'C8.mp3'
        },
        baseUrl: 'https://tonejs.github.io/audio/salamander/',
        release: 0.4,
        onload: () => { estadoEl.textContent = 'Modo virtual listo.'; }
      }).toDestination();
      estadoEl.textContent = 'Cargando piano virtual‚Ä¶';
    }

    // --- MIDI OUT: reproduce msg MIDI recibido (virtual o f√≠sico) ---
    function playMidiMessage(msg) {
      const [st, note, vel] = msg.data;
      const cmd = st & 0xf0;
      if (modo === "midi" && midiOutput) {
        midiOutput.send(new Uint8Array(msg.data));
      }
      if (modo === "virtual" && sampler) {
        const freq = Tone.Frequency(note, 'midi').toFrequency();
        if (cmd === 0x90 && vel > 0) {
          const velNorm = vel / 127;
          const velScaled = Math.pow(velNorm, 2);
          sampler.triggerAttack(freq, Tone.now(), velScaled);
          notasActivas.add(freq);
          notasSostenidas.delete(freq);
        } else if (cmd === 0x80 || (cmd === 0x90 && vel === 0)) {
          if (pedal) {
            notasActivas.delete(freq);
            notasSostenidas.add(freq);
          } else {
            sampler.triggerRelease(freq, Tone.now());
            notasActivas.delete(freq);
            notasSostenidas.delete(freq);
          }
        } else if (st === 176 && note === 64) {
          pedal = vel >= 64;
          if (!pedal) {
            notasSostenidas.forEach(f => {
              if (!notasActivas.has(f)) {
                sampler.triggerRelease(f, Tone.now());
                notasSostenidas.delete(f);
              }
            });
          }
        }
      }
    }

    // --- MIDI IN: env√≠a MIDI tocado localmente al oyente ---
    function sendMidiMessage(data) {
      if (midiChannelOut && midiChannelOut.readyState === "open") {
        midiChannelOut.send(JSON.stringify({ data: Array.from(data) }));
      }
    }

    // --- MIDI DETECTION Y ENV√çO ---
    function listenMidiInput() {
      if (!midiAccess) return;
      const inputs = Array.from(midiAccess.inputs.values());
      if (!inputs.length) return;
      inputs.forEach(input => {
        input.onmidimessage = ({ data }) => {
          sendMidiMessage(data);
          // Adem√°s, sonido local en el modo seleccionado
          playMidiMessage({ data });
        };
      });
      estadoEl.textContent = `Escuchando entrada MIDI: ${inputs.map(i=>i.name).join(", ")}`;
    }

    // --- WALKIE-TALKIE "MUTE REAL" ---
    function createSilentAudioTrack() {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = ctx.createOscillator();
      oscillator.frequency.value = 0;
      const dst = ctx.createMediaStreamDestination();
      oscillator.connect(dst);
      oscillator.start();
      setTimeout(()=>oscillator.stop(), 100);
      return dst.stream.getAudioTracks()[0];
    }
    function updateMicState() {
      if (!audioSender) return;
      const activar = pressingTalk && !remoteSpeaking;
      if (activar) {
        if (audioSender.track !== realAudioTrack)
          audioSender.replaceTrack(realAudioTrack);
      } else {
        if (audioSender.track !== silentAudioTrack)
          audioSender.replaceTrack(silentAudioTrack);
      }
    }
    function pressTalk(){
      pressingTalk=true;
      ws.send(JSON.stringify({type:'talk',speaking:true}));
      updateMicState();
    }
    function releaseTalk(){
      pressingTalk=false;
      ws.send(JSON.stringify({type:'talk',speaking:false}));
      updateMicState();
    }
    ['mousedown','touchstart'].forEach(e=>talkBtn.addEventListener(e,pressTalk));
    ['mouseup','mouseleave','touchend','touchcancel'].forEach(e=>talkBtn.addEventListener(e,releaseTalk));

    // --- WEBRTC: inicio y se√±alizaci√≥n ---
    let realAudioTrack = null;
    let silentAudioTrack = null;
    let audioSender = null;

    async function startWebRTC(){
      try{
        localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
        realAudioTrack = localStream.getAudioTracks()[0];
        silentAudioTrack = createSilentAudioTrack();
        localVideo.srcObject = localStream;
        localStream.getTracks().forEach(t=>{
          let sender = pc.addTrack(t, localStream);
          if(t.kind==='audio') audioSender = sender;
        });
        // Empieza muteado (pista silenciosa)
        if(audioSender && audioSender.track !== silentAudioTrack)
          audioSender.replaceTrack(silentAudioTrack);

        // --- MIDI DataChannel "midi-artista" para enviar (abierto por artista) ---
        midiChannelOut = pc.createDataChannel("midi-artista");
        midiChannelOut.onopen = () => {
          estadoEl.textContent += " | Canal MIDI listo";
          listenMidiInput();
        };

        // El canal para recibir MIDI del oyente se crea en ondatachannel
        // (ver m√°s abajo)

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        sendSignal({offer:pc.localDescription});
      }catch(err){
        console.error(err);estadoEl.innerText='Error al iniciar WebRTC.';
      }
    }

    function sendSignal(d){ws.send(JSON.stringify({type:'signal',...d}));}

    ws.onopen = ()=>{estadoEl.innerText='Conectado. Iniciando WebRTC...';startWebRTC();};
    ws.onmessage = async ({data})=>{
      const msg = JSON.parse(typeof data==='string'?data:await data.text());
      if(msg.type==='stats'){
        oyentesEl.innerText=`Oyentes conectados: ${msg.clients}`;
        // Si hay un nuevo oyente, renegociamos
        if(msg.clients>1) startWebRTC();
        return;
      }
      if(msg.type==='chat'){appendChat(msg.user,msg.text);return;}
      if(msg.type==='talk'){ remoteSpeaking = msg.speaking; updateMicState(); return; }
      if(msg.type==='signal'){
        if(msg.offer){
          await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          sendSignal({answer:pc.localDescription});
        }
        if(msg.answer) await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
        if(msg.candidate) await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
      }
    };
    ws.onerror = ()=>estadoEl.innerText='Error en la conexi√≥n.';
    ws.onclose = ()=>estadoEl.innerText='Conexi√≥n cerrada.';

    pc.onicecandidate = ({candidate})=>{if(candidate) sendSignal({candidate});};
    pc.ontrack = ({streams})=>{
      if(remoteVideo.srcObject!==streams[0]) remoteVideo.srcObject = streams[0];
    };

    // --- DataChannel MIDI bidireccional ---
    pc.ondatachannel = ev => {
      // Esperamos canal "midi-oyente" creado por el oyente
      if(ev.channel.label === "midi-oyente") {
        midiChannelIn = ev.channel;
        midiChannelIn.onmessage = ({data}) => {
          try {
            const msg = JSON.parse(data);
            if (msg.data) playMidiMessage(msg);
          } catch (e) { /* ignorar */ }
        };
      }
    };

    // --- CHAT ---
    function appendChat(u,t){
      const e=document.createElement('div');
      e.innerHTML=`<small>[${new Date().toLocaleTimeString()}]</small> <strong>${u}:</strong> ${t}`;
      if(u===username) e.classList.add('msg-artista');
      chatLog.appendChild(e); chatLog.scrollTop=chatLog.scrollHeight;
    }
    function sendChat(){
      const t=chatInput.value.trim();
      if(t&&ws.readyState===WebSocket.OPEN){ws.send(JSON.stringify({type:'chat',user:username,text:t}));chatInput.value='';}
    }
    sendChatBtn.addEventListener('click',sendChat);
    chatInput.addEventListener('keydown',e=>{if(e.key==='Enter')sendChat();});

    // --- Opcional: activa modo MIDI por defecto al cargar
    //modoMIDI();
  </script>
</body>
</html>
