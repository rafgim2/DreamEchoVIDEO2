<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>DreamEcho - Artista</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: sans-serif;
      background-color: #f5f5f5;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
    }
    .container {
      max-width: 600px;
      width: 90%;
      padding: 2em;
      background: white;
      border-radius: 1em;
      border: 3px solid orange;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
    }
    h1 {
      font-size: 3em;
      margin-bottom: 0.2em;
    }
    video {
      width: 100%;
      max-height: 300px;
      border-radius: 0.5em;
      margin-bottom: 1em;
      background: black;
    }
    .byline {
      margin-bottom: 0.8em;
      font-size: 0.9em;
    }
    .byline a {
      color: #333;
      text-decoration: none;
    }
    .byline a:hover {
      text-decoration: underline;
    }
    p {
      font-size: 1.2em;
      margin: 0.5em 0;
    }
    #chatLog {
      height: 150px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 0.5em;
      margin-bottom: 0.5em;
      text-align: left;
      background: #fafafa;
    }
    #chatInput {
      width: 70%;
      padding: 0.5em;
      font-size: 1em;
    }
    #sendChatBtn {
      padding: 0.6em 1em;
      font-size: 1em;
      cursor: pointer;
      margin-left: 0.5em;
    }
    #midiSelect { margin: 1em 0; padding: 0.5em; font-size: 1em; }
    #midiLabel { font-size: 1em; margin-right: 0.5em; }
    .msg-artista { color: blue; }
  </style>
</head>
<body>
  <div class="container">
    <h1>DreamEcho - Artista</h1>
    <p class="byline">
      <a href="https://www.youtube.com/@rafgim" target="_blank" rel="noopener">¬© By Rafael Gimeno</a>
    </p>
    <!-- V√≠deo local -->
    <video id="localVideo" autoplay muted playsinline></video>
    <!-- V√≠deo remoto (si se recibe de un SFU o eco) -->
    <video id="remoteVideo" autoplay playsinline style="display:none;"></video>

    <p id="estado">Conectando...</p>
    <p id="oyentes">Oyentes conectados: --</p>

    <div id="midiControles" style="display: none;">
      <label id="midiLabel" for="midiSelect">Selecciona tu dispositivo MIDI:</label>
      <select id="midiSelect"></select>
    </div>

    <div id="chatControles">
      <div id="chatLog"></div>
      <input id="chatInput" placeholder="Escribe tu mensaje‚Ä¶" />
      <button id="sendChatBtn">üó®Ô∏è Enviar</button>
    </div>
  </div>

  <script>
    const estadoEl    = document.getElementById("estado");
    const oyentesEl   = document.getElementById("oyentes");
    const chatLog     = document.getElementById("chatLog");
    const chatInput   = document.getElementById("chatInput");
    const sendChatBtn = document.getElementById("sendChatBtn");
    const midiControles = document.getElementById("midiControles");
    const midiSelect    = document.getElementById("midiSelect");

    const localVideo  = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");

    // Conexi√≥n WebSocket para se√±alizaci√≥n y chat
    const ws = new WebSocket("wss://dreamecho.onrender.com");

    // PeerConnection para WebRTC
    const pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });
    let midiChannel;
    let startTime = null;

    // Enviar mensajes de se√±alizaci√≥n
    function sendSignal(data) {
      ws.send(JSON.stringify({ type: 'signal', ...data }));
    }

    // ICE candidates
    pc.onicecandidate = ({ candidate }) => {
      if (candidate) sendSignal({ candidate });
    };

    // Recepci√≥n de pista remota
    pc.ontrack = ev => {
      remoteVideo.srcObject = ev.streams[0];
      remoteVideo.style.display = 'block';
    };

    // Recepci√≥n de canal de datos MIDI
    pc.ondatachannel = e => {
      if (e.channel.label === 'midi') {
        midiChannel = e.channel;
        setupMidiReception();
      }
    };

    // Iniciar la captura y oferta
    async function startWebRTC() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        stream.getTracks().forEach(track => pc.addTrack(track, stream));
        localVideo.srcObject = stream;

        // Crear canal MIDI
        midiChannel = pc.createDataChannel('midi');
        setupMidiChannel();

        // Crear oferta
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        sendSignal({ offer });

      } catch (err) {
        console.error('Error en WebRTC:', err);
        estadoEl.innerText = 'Error al iniciar WebRTC.';
      }
    }

    // Gesti√≥n de canal de datos MIDI (emisor)
    function setupMidiChannel() {
      midiChannel.onopen = () => {
        estadoEl.innerText = estadoEl.innerText + ' | Canal MIDI listo';
      };
    }

    // Gesti√≥n de recepci√≥n de MIDI (no usado en artista)
    function setupMidiReception() {
      midiChannel.onmessage = ({ data }) => {
        // No procesamos MIDI en el artista
      };
    }

    // Manejador de mensajes WS
    ws.onopen = () => {
      estadoEl.innerText = 'Conectado. Iniciando WebRTC...';
      startWebRTC();
    };

    ws.onmessage = async event => {
      const text = await event.data.text();
      const msg  = JSON.parse(text);

      switch (msg.type) {
        case 'signal':
          if (msg.offer) {
            await pc.setRemoteDescription(msg.offer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            sendSignal({ answer });
          }
          if (msg.answer) {
            await pc.setRemoteDescription(msg.answer);
          }
          if (msg.candidate) {
            await pc.addIceCandidate(msg.candidate);
          }
          break;
        case 'stats':
          oyentesEl.innerText = `Oyentes conectados: ${msg.clients}`;
          break;
        case 'chat':
          appendChat(msg.user, msg.text);
          break;
        // El artista no recibe eventos 'midi' por WS, van por DataChannel
      }
    };

    ws.onclose = () => { estadoEl.innerText = 'Conexi√≥n cerrada.'; };
    ws.onerror = e => { estadoEl.innerText = 'Error en la conexi√≥n.'; console.error(e); };

    const username = prompt("¬øC√≥mo quieres que te vean en el chat?", "Artista") || "Artista";
    function appendChat(user, text) {
      const msg = document.createElement("div");
      const time = new Date().toLocaleTimeString();
      if (user === username) msg.classList.add('msg-artista');
      msg.innerHTML = `<small>[${time}]</small> <strong>${user}:</strong> ${text}`;
      chatLog.appendChild(msg);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function sendChat() {
      const text = chatInput.value.trim();
      if (!text || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type: "chat", user: username, text }));
      chatInput.value = '';
    }

    sendChatBtn.addEventListener('click', sendChat);
    chatInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendChat(); });

    // MIDI Access
    navigator.requestMIDIAccess().then(midiAccess => {
      const inputs = midiAccess.inputs;
      if (inputs.size === 0) {
        estadoEl.innerText = 'No se detectaron dispositivos MIDI.';
        return;
      }
      midiControles.style.display = 'block';
      inputs.forEach((input, id) => {
        const opt = document.createElement('option');
        opt.value = id; opt.text = input.name;
        midiSelect.appendChild(opt);
      });
      midiSelect.addEventListener('change', () => selectMIDI(midiSelect.value, midiAccess));
      selectMIDI(midiSelect.value, midiAccess);
      estadoEl.innerText = 'Selecciona un dispositivo MIDI para empezar.';
    }).catch(() => { estadoEl.innerText = 'No se pudo acceder al MIDI.'; });

    let activeInput = null;
    function selectMIDI(id, midiAccess) {
      if (activeInput) activeInput.onmidimessage = null;
      const inp = midiAccess.inputs.get(id);
      if (!inp) { estadoEl.innerText = 'MIDI no encontrado.'; return; }
      inp.onmidimessage = handleMIDI;
      activeInput = inp;
      estadoEl.innerText = `Transmitiendo desde: ${inp.name}`;
      startTime = null;
    }

    function handleMIDI(evt) {
      const now = performance.now();
      if (startTime === null) startTime = now;
      const rel = now - startTime;
      if (midiChannel && midiChannel.readyState === 'open') {
        midiChannel.send(JSON.stringify({ data: Array.from(evt.data), time: rel }));
      }
    }
  </script>
</body>
</html>
